######################################################################
# This file was autogenerated by `make`. Do not edit it directly!
######################################################################
# Antigen: A simple plugin manager for zsh
# Authors: Shrikant Sharat Kandula
#          and Contributors <https://github.com/zsh-users/antigen/contributors>
# Homepage: http://antigen.sharats.me
# License: MIT License <mitl.sharats.me>
zmodload zsh/parameter

if [[ $ANTIGEN_CACHE != false ]]; then
  ANTIGEN_CACHE="${ANTIGEN_CACHE:-${ADOTDIR:-$HOME/.antigen}/init.zsh}"
  ANTIGEN_RSRC="${ADOTDIR:-$HOME/.antigen}/.resources"

  if [[ $ANTIGEN_AUTO_CONFIG != false && -f $ANTIGEN_RSRC ]]; then
    ANTIGEN_CHECK_FILES=$(cat $ANTIGEN_RSRC 2> /dev/null)
    ANTIGEN_CHECK_FILES=(${(@f)ANTIGEN_CHECK_FILES})

    for config in $ANTIGEN_CHECK_FILES; do
      if [[ "$config" -nt "$config.zwc" ]]; then
        { zcompile "$config" } &!
        [[ -f "$ANTIGEN_CACHE" ]] && rm -f "$ANTIGEN_CACHE"
      fi
    done
  fi

  [[ -f $ANTIGEN_CACHE && ! $_ANTIGEN_CACHE_LOADED == true ]] && source "$ANTIGEN_CACHE" && return 0;
fi
[[ -z "$_ANTIGEN_INSTALL_DIR" ]] && _ANTIGEN_INSTALL_DIR=${0:A:h}

# Each line in this string has the following entries separated by a space
# character.
# <repo-url>, <plugin-location>, <bundle-type>, <has-local-clone>
[[ $_ANTIGEN_CACHE_LOADED != true ]] && typeset -aU _ANTIGEN_BUNDLE_RECORD

# Do not load anything if git is not available.
if (( ! $+commands[git] )); then
    echo 'Antigen: Please install git to use Antigen.' >&2
    return 1
fi

# Used to defer compinit/compdef
typeset -a __deferred_compdefs
compdef () { __deferred_compdefs=($__deferred_compdefs "$*") }

# A syntax sugar to avoid the `-` when calling antigen commands. With this
# function, you can write `antigen-bundle` as `antigen bundle` and so on.
antigen () {
  local cmd="$1"
  if [[ -z "$cmd" ]]; then
    echo 'Antigen: Please give a command to run.' >&2
    return 1
  fi
  shift

  if (( $+functions[antigen-$cmd] )); then
      "antigen-$cmd" "$@"
      return $?
  else
      echo "Antigen: Unknown command: $cmd" >&2
      return 1
  fi
}
# Returns the bundle's git revision
#
# Usage
#   -antigen-bundle-rev bundle-name [is_local_clone]
#
# Returns
#   Bundle rev-parse output (branch name or short ref name)
-antigen-bundle-rev () {
  local bundle=$1
  local is_local_clone=$2

  local bundle_path=$bundle
  # Get bunde path inside $ADOTDIR if bundle was effectively cloned
  if [[ "$is_local_clone" == "true" ]]; then
    bundle_path=$(-antigen-get-clone-dir $bundle)
  fi

  local ref
  ref=$(git --git-dir="$bundle_path/.git" rev-parse --abbrev-ref '@' 2>/dev/null)

  # Avoid 'HEAD' when in detached mode
  if [[ $ref == "HEAD" ]]; then
    ref=$(git --git-dir="$bundle_path/.git" describe --tags --exact-match 2>/dev/null \
	    || git --git-dir="$bundle_path/.git" rev-parse --short '@' 2>/dev/null || "-")
  fi
  echo $ref
}
# Usage:
#   -antigen-bundle-short-name "https://github.com/user/repo.git[|*]" "[branch/name]"
# Returns:
#   user/repo@branch/name
-antigen-bundle-short-name () {
  local bundle_name="${1%|*}"
  local bundle_branch="$2"
  local match mbegin mend MATCH MBEGIN MEND

  [[ "$bundle_name" =~ '.*/(.*/.*).*$' ]] && bundle_name=$match[1]
  bundle_name="${bundle_name%.git*}"

  if [[ -n $bundle_branch ]]; then
    bundle_name="$bundle_name@$bundle_branch"
  fi

  echo $bundle_name
}
# Echo the bundle specs as in the record. The first line is not echoed since it
# is a blank line.
-antigen-echo-record () {
  echo ${(j:\n:)_ANTIGEN_BUNDLE_RECORD}
}
# Filters _ANTIGEN_BUNDLE_RECORD for $1
#
# Usage
#   -antigen-find-bundle example/bundle
#
# Returns
#   String if bundle is found
-antigen-find-bundle () {
  echo $(-antigen-find-record $1 | cut -d' ' -f1)
}

# Filters _ANTIGEN_BUNDLE_RECORD for $1
#
# Usage
#   -antigen-find-record example/bundle
#
# Returns
#   String if record is found
-antigen-find-record () {
  local bundle=$1
  
  if [[ $# -eq 0 ]]; then
    return 1
  fi

  local record=${bundle/\|/\\\|}
  echo "${_ANTIGEN_BUNDLE_RECORD[(r)*$record*]}"
}
# Returns bundle names from _ANTIGEN_BUNDLE_RECORD
#
# Usage
#   -antigen-get-bundles [--short|--simple|--long]
#
# Returns
#   List of bundles installed
-antigen-get-bundles () {
  local mode revision url bundle_name bundle_entry loc no_local_clone
  local record bundle make_local_clone
  mode=${1:-"--short"}

  for record in $_ANTIGEN_BUNDLE_RECORD; do
    bundle=(${(@s/ /)record})
    url=$bundle[1]
    loc=$bundle[2]
    make_local_clone=$bundle[4]

    bundle_name=$(-antigen-bundle-short-name $url)

    case "$mode" in
        --short)
          # Only check revision for bundle with a requested branch
          if [[ $url == *\|* ]]; then
            revision=$(-antigen-bundle-rev $url $make_local_clone)
          else
            revision="master"
          fi

          if [[ $loc != '/' ]]; then
            bundle_name="$bundle_name ~ $loc"
          fi
          echo "$bundle_name @ $revision"
        ;;
        --simple)
          echo "$bundle_name"
        ;;
        --long)
          echo "$record"
        ;;
     esac
  done
}
# Usage:
#  -antigen-get-clone-dir "https://github.com/zsh-users/zsh-syntax-highlighting.git[|feature/branch]"
# Returns:
#  $ANTIGEN_BUNDLES/zsh-users/zsh-syntax-highlighting[-feature-branch]
-antigen-get-clone-dir () {
  local bundle="$1"
  local url="${bundle%|*}"
  local branch match mbegin mend MATCH MBEGIN MEND
  [[ "$bundle" =~ "\|" ]] && branch="${bundle#*|}"

  # Takes a repo url and mangles it, giving the path that this url will be
  # cloned to. Doesn't actually clone anything.
  local clone_dir="$ANTIGEN_BUNDLES"

  url=$(-antigen-bundle-short-name $url)

  # Suffix with branch/tag name
  [[ -n "$branch" ]] && url="$url-${branch//\//-}"
  url=${url//\*/x}

  echo "$clone_dir/$url"
}
# Returns bundles flagged as make_local_clone
#
# Usage
#    -antigen-cloned-bundles
#
# Returns
#    Bundle metadata
-antigen-get-cloned-bundles() {
  -antigen-echo-record |
      awk '$4 == "true" {print $1}' |
      sort -u
}
# Returns a list of themes from a default library (omz)
#
# Usage
#   -antigen-get-themes
#
# Returns
#   List of themes by name
-antigen-get-themes () {
  local library='robbyrussell/oh-my-zsh'
  local bundle=$(-antigen-find-bundle $library)

  if [[ -n "$bundle" ]]; then
    local dir=$(-antigen-get-clone-dir $ANTIGEN_DEFAULT_REPO_URL)
    echo $(ls $dir/themes | sed 's/.zsh-theme//')
  fi

  return 0
}

# This function check ZSH_EVAL_CONTEXT to determine if running in interactive shell. 
#
# Usage
#   -antigen-interactive-mode
#
# Returns
#   Either true or false depending if we are running in interactive mode
-antigen-interactive-mode () {
  [[ "$ZSH_EVAL_CONTEXT" == toplevel* || "$ZSH_EVAL_CONTEXT" == cmdarg* ]];
}
# Parses and retrieves a remote branch given a branch name.
#
# If the branch name contains '*' it will retrieve remote branches
# and try to match against tags and heads, returning the latest matching.
#
# Usage
#     -antigen-parse-branch https://github.com/user/repo.git x.y.z
#
# Returns
#     Branch name
-antigen-parse-branch () {
  local url="$1" branch="$2" branches
  
  local match mbegin mend MATCH MBEGIN MEND

  if [[ "$branch" =~ '\*' ]]; then
    branches=$(git ls-remote --tags -q "$url" "$branch"|cut -d'/' -f3|sort -n|tail -1)
    # There is no --refs flag in git 1.8 and below, this way we
    # emulate this flag -- also git 1.8 ref order is undefined.
    branch=${${branches#*/*/}%^*} # Why you are like this?
  fi

  echo $branch
}
-antigen-update-repos () {
  local repo bundle url target
  local log=/tmp/antigen-v2-migrate.log

  echo "It seems you have bundles cloned with Antigen v1.x."
  echo "We'll try to convert directory structure to v2."
  echo

  echo -n "Moving bundles to '\$ADOTDIR/bundles'... "

  # Migrate old repos -> bundles
  local errors=0
  for repo in $ADOTDIR/repos/*; do
    bundle=${repo/$ADOTDIR\/repos\//}
    bundle=${bundle//-SLASH-/\/}
    bundle=${bundle//-COLON-/\:}
    bundle=${bundle//-STAR-/\*}
    url=${bundle//-PIPE-/\|}
    target=$(-antigen-get-clone-dir $url)
    mkdir -p "${target:A:h}"
    echo " ---> ${repo/$ADOTDIR\/} -> ${target/$ADOTDIR\/}" | tee > $log
    mv "$repo" "$target" &> $log
    if [[ $? != 0 ]]; then
      echo "Failed to migrate '$repo'!."
      errors+=1
    fi
  done

  if [[ $errors == 0 ]]; then
    echo "Done."
  else
    echo "An error ocurred!"
  fi
  echo

  if [[ "$(ls -A $ADOTDIR/repos | wc -l | xargs)" == 0 ]]; then
    echo "You can safely remove \$ADOTDIR/repos."
  else
    echo "Some bundles couldn't be migrated. See \$ADOTDIR/repos."
  fi

  echo
  if [[ $errors == 0 ]]; then
    echo "Bundles migrated successfuly."
    rm $log
  else
    echo "Some errors occured. Review migration log in '$log'."
  fi
  antigen-reset
}
# Ensure that a clone exists for the given repo url and branch. If the first
# argument is `update` and if a clone already exists for the given repo
# and branch, it is pull-ed, i.e., updated.
#
# This function expects three arguments in order:
# - 'url=<url>'
# - 'update=true|false'
# - 'verbose=true|false'
#
# Returns true|false Whether cloning/pulling was succesful
-antigen-ensure-repo () {
  # Argument defaults. Previously using ${1:?"missing url argument"} format
  # but it seems to mess up with cram
  if (( $# < 1 )); then
    echo "Antigen: Missing url argument."
    return 1
  fi

  # The url. No sane default for this, so just empty.
  local url=$1
  # Check if we have to update.
  local update=${2:-false}
  # Verbose output.
  local verbose=${3:-false}

  shift $#

  # Get the clone's directory as per the given repo url and branch.
  local clone_dir=$(-antigen-get-clone-dir $url)
  if [[ -d "$clone_dir" && $update == false ]]; then
    return true
  fi

  # A temporary function wrapping the `git` command with repeated arguments.
  --plugin-git () {
    (cd -q "$clone_dir" && eval ${ANTIGEN_CLONE_ENV} git --git-dir="$clone_dir/.git" --no-pager "$@" &>>! $ANTIGEN_LOG)
  }

  local success=false

  # If its a specific branch that we want, checkout that branch.
  local branch="master" # TODO FIX THIS
  if [[ $url == *\|* ]]; then
    branch="$(-antigen-parse-branch ${url%|*} ${url#*|})"
  fi

  if [[ ! -d $clone_dir ]]; then
    eval ${ANTIGEN_CLONE_ENV} git clone ${=ANTIGEN_CLONE_OPTS} --branch "$branch" -- "${url%|*}" "$clone_dir" &>> $ANTIGEN_LOG
    success=$?
  elif $update; then
    # Save current revision.
    local old_rev="$(--plugin-git rev-parse HEAD)"
    # Pull changes if update requested.
    --plugin-git checkout "$branch"
    --plugin-git pull origin "$branch"
    success=$?

    # Update submodules.
    --plugin-git submodule update ${=ANTIGEN_SUBMODULE_OPTS}
    # Get the new revision.
    local new_rev="$(--plugin-git rev-parse HEAD)"
  fi

  if [[ -n $old_rev && $old_rev != $new_rev ]]; then
    echo Updated from $old_rev[0,7] to $new_rev[0,7].
    if $verbose; then
      --plugin-git log --oneline --reverse --no-merges --stat '@{1}..'
    fi
  fi

  # Remove the temporary git wrapper function.
  unfunction -- --plugin-git

  return $success
}
# Helper function: Same as `$1=$2`, but will only happen if the name
# specified by `$1` is not already set.
-antigen-set-default () {
  local arg_name="$1"
  local arg_value="$2"
  eval "test -z \"\$$arg_name\" && typeset -g $arg_name='$arg_value'"
}

-antigen-env-setup () {
  typeset -gU fpath path

  # Pre-startup initializations.
  -antigen-set-default ANTIGEN_DEFAULT_REPO_URL \
      https://github.com/robbyrussell/oh-my-zsh.git
  -antigen-set-default ANTIGEN_PREZTO_REPO_URL \
      https://github.com/sorin-ionescu/prezto.git

  -antigen-set-default ADOTDIR $HOME/.antigen
  [[ ! -d $ADOTDIR ]] && mkdir -p $ADOTDIR

  -antigen-set-default ANTIGEN_BUNDLES $ADOTDIR/bundles
  if [[ ! -d $ANTIGEN_BUNDLES ]]; then
    mkdir -p $ANTIGEN_BUNDLES
    [[ -d $ADOTDIR/repos ]] && -antigen-update-repos
  fi

  -antigen-set-default ANTIGEN_COMPDUMP "${ADOTDIR:-$HOME}/.zcompdump"

  -antigen-set-default ANTIGEN_LOG /dev/null

  # CLONE_OPTS uses ${=CLONE_OPTS} expansion so don't use spaces
  # for arguments that can be passed as `--key=value`.
  -antigen-set-default ANTIGEN_CLONE_ENV "GIT_TERMINAL_PROMPT=0"
  -antigen-set-default ANTIGEN_CLONE_OPTS "--single-branch --recursive --depth=1"
  -antigen-set-default ANTIGEN_SUBMODULE_OPTS "--recursive --depth=1"
  
  # Complain when a bundle is already installed.
  -antigen-set-default _ANTIGEN_WARN_DUPLICATES true

  # Setup antigen's own completion.
  if -antigen-interactive-mode; then
    autoload -Uz compinit
    compinit -C -d "$ANTIGEN_COMPDUMP"
    compdef _antigen antigen
  else
    # Initialize extensions. unless in interactive mode.
    #antigen-ext defer
    [[ $ANTIGEN_CACHE != false ]] && antigen-ext cache
    antigen-ext lock
  fi
}
# Load a given bundle by sourcing it.
#
# The function also modifies fpath to add the bundle path.
#
# Usage
#   -antigen-load "bundle-url" ["location"] ["make_local_clone"] ["btype"]
#
# Returns
#   Integer. 0 if success 1 if an error ocurred.
-antigen-load () {
  typeset -A bundle; bundle=($@)

  typeset -Ua list; list=()
  local location=${bundle[path]}/${bundle[loc]}

  # Prioritize location when given.
  if [[ -f ${location} ]]; then
    list=(${location})
  else
    # Directory locations must be suffixed with slash
    location="$location/"

    # Prioritize theme with antigen-theme
    if [[ ${bundle[btype]} == "theme" ]]; then
      list=(${location}*.zsh-theme(N[1]))
    fi

    # Common frameworks
    if [[ $#list == 0 ]]; then
      list=(${location}*.plugin.zsh(N[1]) ${location}init.zsh(N[1]))
    fi

    # Default to zsh and sh
    if [[ $#list == 0 ]]; then
      list=(${location}*.zsh(N) ${location}*.sh(N))
    fi
  fi

  -antigen-load-env ${(kv)bundle}

  # If there is any sourceable try to load it
  if ! -antigen-load-source && [[ ! -d ${location} ]]; then
    return 1
  fi

  return 0
}

-antigen-load-env () {
  typeset -A bundle; bundle=($@)
  local location=${bundle[path]}/${bundle[loc]}
  
  # Support prezto function loading. See https://github.com/zsh-users/antigen/pull/428
  if [[ -d "${location}/functions" ]]; then
    PATH="$PATH:${location:A}/functions"
    fpath+=("${location:A}/functions")
  fi
  
  # Load to path if there is no sourceable
  if [[ -d ${location} ]]; then
    PATH="$PATH:${location:A}"
    fpath+=("${location:A}")
    return
  fi

  PATH="$PATH:${location:A:h}"
  fpath+=("${location:A:h}")
}

-antigen-load-source () {
  local src match mbegin mend MATCH MBEGIN MEND

  # Return error when we're given an empty list
  if [[ $#list == 0 ]]; then
    return 1
  fi
  
  # Using a for rather than `source $list` as we need to check for zsh-themes
  # In order to create antigen-compat file. This is only needed for interactive-mode
  # theme switching, for static loading (cache) there is no need.
  for src in $list; do
    if [[ $_ANTIGEN_THEME_COMPAT == true  && -f "$src" && "$src" == *.zsh-theme* ]]; then
      local compat="${src:A}.antigen-compat"
      echo "# Generated by Antigen. Do not edit!" >! "$compat"
      cat $src | sed -Ee '/\{$/,/^\}/!{
             s/^local //
         }' >>! "$compat"
      src="$compat"
    fi

    if ! source "$src" 2>/dev/null; then
      return 1
    fi
  done
}
# Usage:
#   -antigen-parse-args output_assoc_arr <args...>
-antigen-parse-args () {
  local argkey key value index=0
  local match mbegin mend MATCH MBEGIN MEND

  local var=$1
  shift

  # Bundle spec arguments' default values.
  typeset -A args
  args[url]="$ANTIGEN_DEFAULT_REPO_URL"
  args[loc]=/
  args[make_local_clone]=true
  args[btype]=plugin
  #args[branch]= # commented out as it may cause assoc array kv mismatch

  while [[ $# -gt 0 ]]; do
    argkey="${1%\=*}"
    key="${argkey//--/}"
    value="${1#*=}"

    case "$argkey" in
      --url|--loc|--branch|--btype)
        if [[ "$value" == "$argkey" ]]; then
          printf "Required argument for '%s' not provided.\n" $key >&2
        else
          args[$key]="$value"
        fi
      ;;
      --no-local-clone)
        args[make_local_clone]=false
      ;;
      --*)
        printf "Unknown argument '%s'.\n" $key >&2
      ;;
      *)
        value=$key
        case $index in
          0)
            key=url
            local domain=""
            local url_path=$value
            # Full url with protocol or ssh github url (github.com:org/repo)
            if [[ "$value" =~ "://" || "$value" =~ ":" ]]; then
              if [[ "$value" =~ [@.][^/:]+[:]?[0-9]*[:/]?(.*)@?$ ]]; then
                url_path=$match[1]
                domain=${value/$url_path/}
              fi
            fi

            if [[ "$url_path" =~ '@' ]]; then
              args[branch]="${url_path#*@}"
              value="$domain${url_path%@*}"
            else
              value="$domain$url_path"
            fi
          ;;
          1) key=loc ;;
        esac
        let index+=1
        args[$key]="$value"
      ;;
    esac

    shift
  done
  
  # Check if url is just the plugin name. Super short syntax.
  if [[ "${args[url]}" != */* ]]; then
    args[loc]="plugins/${args[url]}"
    args[url]="$ANTIGEN_DEFAULT_REPO_URL"
  fi

  # Resolve the url.
  # Expand short github url syntax: `username/reponame`.
  local url="${args[url]}"
  if [[ $url != git://* &&
          $url != https://* &&
          $url != http://* &&
          $url != ssh://* &&
          $url != /* &&
          $url != *github.com:*/*
          ]]; then
    url="https://github.com/${url%.git}.git"
  fi
  args[url]="$url"

  # Ignore local clone if url given is not a git directory
  if [[ ${args[url]} == /* && ! -d ${args[url]}/.git ]]; then
    args[make_local_clone]=false
  fi

  # Add the branch information to the url if we need to create a local clone.
  # Format url in bundle-metadata format: url[|branch]
  if [[ ! -z "${args[branch]}" && ${args[make_local_clone]} == true ]]; then
    args[url]="${args[url]}|${args[branch]}"
  fi

  # Add the theme extension to `loc`, if this is a theme, but only
  # if it's especified, ie, --loc=theme-name, in case when it's not
  # specified antige-load-list will look for *.zsh-theme files
  if [[ ${args[btype]} == "theme" &&
      ${args[loc]} != "/" && ${args[loc]} != *.zsh-theme ]]; then
      args[loc]="${args[loc]}.zsh-theme"
  fi

  # Format bundle name
  local name="${args[url]%|*}"
  if [[ "$name" =~ '.*/(.*/.*).*$' ]]; then
    name="${match[1]}"
  fi
  name="${name%.git*}"
  if [[ -n ${args[branch]} ]]; then
    name="$name@${args[branch]}"
  fi
  args[name]="$name"

  # Bundle path
  if [[ ${args[make_local_clone]} == true ]]; then
    local bpath="${args[name]}"
    # Suffix with branch/tag name
    if [[ -n "${args[branch]}" ]]; then
      # bpath is in the form of repo/name@version => repo/name-version
      bpath="${bpath//\@/-}"
      # If branch/tag is semver-like do replace * by x.
      bpath=${bpath//\*/x}
    fi

    bpath="$ANTIGEN_BUNDLES/$bpath"
    args[path]="${(qq)bpath}"
  else
    # if it's local then path is just the "url" argument, loc remains the same
    args[path]=${args[url]}
  fi
  
  # Escape url and branch (may contain semver-like and pipe characters)
  args[url]="${(qq)args[url]}"
  if [[ -n "${args[branch]}" ]]; then
    args[branch]="${(qq)args[branch]}"
  fi
  
  # Escape bundle name (may contain semver-like characters)
  args[name]="${(qq)args[name]}"

  eval "${var}=(${(kv)args})"

  return 0
}
# Updates revert-info data with git hash.
#
# This does process only cloned bundles.
#
# Usage
#    -antigen-revert-info
#
# Returns
#    Nothing. Generates/updates $ADOTDIR/revert-info.
-antigen-revert-info() {
  local url
  # Update your bundles, i.e., `git pull` in all the plugin repos.
  date >! $ADOTDIR/revert-info

  -antigen-get-cloned-bundles | while read url; do
    local clone_dir="$(-antigen-get-clone-dir "$url")"
    if [[ -d "$clone_dir" ]]; then
      (echo -n "$clone_dir:"
        cd -q "$clone_dir"
        git rev-parse HEAD) >> $ADOTDIR/revert-info
    fi
  done
}
-antigen-use-oh-my-zsh () {
  if [[ -z "$ZSH" ]]; then
    ZSH="$(-antigen-get-clone-dir "$ANTIGEN_DEFAULT_REPO_URL")"
  fi
  if [[ -z "$ZSH_CACHE_DIR" ]]; then
    ZSH_CACHE_DIR="$ZSH/cache/"
  fi
  antigen-bundle --loc=lib
}
-antigen-use-prezto () {
  antigen-bundle "$ANTIGEN_PREZTO_REPO_URL"
}
# Initialize completion
antigen-apply () {
  \rm -f "$ANTIGEN_COMPDUMP"

  # Load the compinit module. This will readefine the `compdef` function to
  # the one that actually initializes completions.
  autoload -Uz compinit
  compinit -C -d "$ANTIGEN_COMPDUMP"
  if [[ ! -f "$ANTIGEN_COMPDUMP.zwc" || "$ANTIGEN_COMPDUMP" -nt "$ANTIGEN_COMPDUMP.zwc" ]]; then
    # Apply all `compinit`s that have been deferred.
    local cdef
    for cdef in "${__deferred_compdefs[@]}"; do
      compdef "$cdef"
    done

    { zcompile "$ANTIGEN_COMPDUMP" } &!
  fi

  unset __deferred_compdefs
}
# Syntaxes
#   antigen-bundle <url> [<loc>=/]
# Keyword only arguments:
#   branch - The branch of the repo to use for this bundle.
antigen-bundle () {
  if [[ -z "$1" ]]; then
    printf "Antigen: Must provide a bundle url or name.\n" >&2
    return 1
  fi

  typeset -A bundle
  -antigen-parse-args 'bundle' "$@"
  if [[ -z ${bundle[btype]} ]]; then
    bundle[btype]=bundle
  fi

  local record="${bundle[url]} ${bundle[loc]} ${bundle[btype]} ${bundle[make_local_clone]}"
  if [[ $_ANTIGEN_WARN_DUPLICATES == true && ! ${_ANTIGEN_BUNDLE_RECORD[(I)$record]} == 0 ]]; then
    printf "Seems %s is already installed!\n" ${bundle[name]}
    return 1
  fi
 
  # Clone bundle if we haven't done do already.
  if [[ ! -d "${bundle[path]}" ]]; then
    if ! -antigen-bundle-install ${(kv)bundle}; then
      return 1
    fi
  fi

  # Load the plugin.
  if ! -antigen-load ${(kv)bundle}; then
    printf "Antigen: Failed to load %s.\n" ${bundle[btype]} >&2
    return 1
  fi
  
  # Only add it to the record if it could be installed and loaded.
  _ANTIGEN_BUNDLE_RECORD+=("$record")
}

#
# Usage:
#   -antigen-bundle-install <record>
# Returns:
#   1 if it fails to install bundle
-antigen-bundle-install () {
  typeset -A bundle; bundle=($@)

  # Ensure a clone exists for this repo, if needed.
  # Get the clone's directory as per the given repo url and branch.
  local bpath="${bundle[path]}"
  # Clone if it doesn't already exist.
  local start=$(date +'%s')

  printf "Installing %s... " "${bundle[name]}"

  if ! -antigen-ensure-repo "${bundle[url]}"; then
    # Return immediately if there is an error cloning
    printf "Error! Activate logging and try again.\n" >&2
    return 1
  fi

  local took=$(( $(date +'%s') - $start ))
  printf "Done. Took %ds.\n" $took
}
antigen-bundles () {
  # Bulk add many bundles at one go. Empty lines and lines starting with a `#`
  # are ignored. Everything else is given to `antigen-bundle` as is, no
  # quoting rules applied.
  local line
  setopt localoptions no_extended_glob # See https://github.com/zsh-users/antigen/issues/456
  grep '^[[:space:]]*[^[:space:]#]' | while read line; do
    antigen-bundle ${=line%#*}
  done
}
# Generate static-cache file at $ANTIGEN_CACHE using currently loaded
# bundles from $_ANTIGEN_BUNDLE_RECORD
#
# Usage
#   antigen-cache-gen
#
# Returns
#   Nothing
antigen-cache-gen () {
  -antigen-cache-generate
}
# Cleanup unused repositories.
antigen-cleanup () {
  local force=false
  if [[ $1 == --force ]]; then
    force=true
  fi

  if [[ ! -d "$ANTIGEN_BUNDLES" || -z "$(\ls -A "$ANTIGEN_BUNDLES")" ]]; then
    echo "You don't have any bundles."
    return 0
  fi

  # Find directores in ANTIGEN_BUNDLES, that are not in the bundles record.
  typeset -a unused_clones clones

  local url record clone
  for record in $(-antigen-get-cloned-bundles); do
    url=${record% /*}
    clones+=("$(-antigen-get-clone-dir $url)")
  done

  for clone in $ANTIGEN_BUNDLES/*/*(/); do
    if [[ $clones[(I)$clone] == 0 ]]; then
      unused_clones+=($clone)
    fi
  done

  if [[ -z $unused_clones ]]; then
    echo "You don't have any unidentified bundles."
    return 0
  fi

  echo 'You have clones for the following repos, but are not used.'
  echo "\n${(j:\n:)unused_clones}"

  if $force || (echo -n '\nDelete them all? [y/N] '; read -q); then
    echo
    echo
    for clone in $unused_clones; do
      echo -n "Deleting clone \"$clone\"..."
      \rm -rf "$clone"

      echo ' done.'
    done
  else
    echo
    echo "Nothing deleted."
  fi
}
antigen-help () {
  antigen-version

  cat <<EOF

Antigen is a plugin management system for zsh. It makes it easy to grab awesome
shell scripts and utilities, put up on Github.

Usage: antigen <command> [args]

Commands:
  apply        Must be called in the zshrc after all calls to 'antigen bundle'.
  bundle       Install and load a plugin.
  cache-gen    Generate Antigen's cache with currently loaded bundles.
  cleanup      Remove clones of repos not used by any loaded plugins.
  init         Use caching to quickly load bundles.
  list         List currently loaded plugins.
  purge        Remove a bundle from the filesystem.
  reset        Clean the generated cache.
  restore      Restore plugin state from a snapshot file.
  revert       Revert plugins to their state prior to the last time 'antigen
               update' was run.
  selfupdate   Update antigen.
  snapshot     Create a snapshot of all active plugin repos and save it to a
               snapshot file.
  update       Update plugins.
  use          Load a supported zsh pre-packaged framework.

For further details and complete documentation, visit the project's page at
'http://antigen.sharats.me'.
EOF
}
# Antigen command to load antigen configuration
#
# This method is slighlty more performing than using various antigen-* methods.
#
# Usage
#   Referencing an antigen configuration file:
#
#       antigen-init "/path/to/antigenrc"
#
#   or using HEREDOCS:
#
#       antigen-init <<EOBUNDLES
#           antigen use oh-my-zsh
#
#           antigen bundle zsh/bundle
#           antigen bundle zsh/example
#
#           antigen theme zsh/theme
#
#           antigen apply
#       EOBUNDLES
#
# Returns
#   Nothing
antigen-init () {
  local src="$1" line

  # If we're given an argument it should be a path to a file
  if [[ -n "$src" ]]; then
    if [[ -f "$src" ]]; then
      source "$src"
      return
    else
      printf "Antigen: invalid argument provided.\n" >&2
      return 1
    fi
  fi

  # Otherwise we expect it to be a heredoc
  grep '^[[:space:]]*[^[:space:]#]' | while read -r line; do
    eval $line
  done
}
# List instaled bundles either in long (record), short or simple format.
#
# Usage
#    antigen-list [--short|--long|--simple]
#
# Returns
#    List of bundles
antigen-list () {
  local format=$1

  # List all currently installed bundles.
  if [[ -z $_ANTIGEN_BUNDLE_RECORD ]]; then
    echo "You don't have any bundles." >&2
    return 1
  fi

  -antigen-get-bundles $format
}
# Remove a bundle from filesystem
#
# Usage
#   antigen-purge example/bundle [--force]
#
# Returns
#   Nothing. Removes bundle from filesystem.
antigen-purge () {
  local bundle=$1
  local force=$2

  if [[ $# -eq 0  ]]; then
    echo "Antigen: Missing argument." >&2
    return 1
  fi

  if -antigen-purge-bundle $bundle $force; then
    antigen-reset
  else
    return $?
  fi

  return 0
}

# Remove a bundle from filesystem
#
# Usage
#   antigen-purge example/bundle [--force]
#
# Returns
#   Nothing. Removes bundle from filesystem.
-antigen-purge-bundle () {
  local bundle=$1
  local force=$2
  local clone_dir=""

  local record=""
  local url=""
  local make_local_clone=""

  if [[ $# -eq 0  ]]; then
    echo "Antigen: Missing argument." >&2
    return 1
  fi

  # local keyword doesn't work on zsh <= 5.0.0
  record=$(-antigen-find-record $bundle)

  if [[ ! -n "$record" ]]; then
    echo "Bundle not found in record. Try 'antigen bundle $bundle' first." >&2
    return 1
  fi

  url="$(echo "$record" | cut -d' ' -f1)"
  make_local_clone=$(echo "$record" | cut -d' ' -f4)

  if [[ $make_local_clone == "false" ]]; then
    echo "Bundle has no local clone. Will not be removed." >&2
    return 1
  fi

  clone_dir=$(-antigen-get-clone-dir "$url")
  if [[ $force == "--force" ]] || read -q "?Remove '$clone_dir'? (y/n) "; then
    # Need empty line after read -q
    [[ ! -n $force ]] && echo "" || echo "Removing '$clone_dir'.";
    rm -rf "$clone_dir"
    return $?
  fi

  return 1
}
# Removes cache payload and metadata if available
#
# Usage
#   antigen-reset
#
# Returns
#   Nothing
antigen-reset () {
  [[ -f "$ANTIGEN_CACHE" ]] && rm -f "$ANTIGEN_CACHE" "$ANTIGEN_CACHE.zwc" 2> /dev/null
  [[ -f "$ANTIGEN_RSRC" ]] && rm -f "$ANTIGEN_RSRC" 2> /dev/null
  [[ -f "$ANTIGEN_COMPDUMP" ]] && rm -f "$ANTIGEN_COMPDUMP" "$ANTIGEN_COMPDUMP.zwc" 2> /dev/null
  [[ -f "$ANTIGEN_LOCK" ]] && rm -f "$ANTIGEN_LOCK" 2> /dev/null
  echo 'Done. Please open a new shell to see the changes.'
}
antigen-restore () {
  local line
  if [[ $# == 0 ]]; then
    echo 'Please provide a snapshot file to restore from.' >&2
    return 1
  fi

  local snapshot_file="$1"

  # TODO: Before doing anything with the snapshot file, verify its checksum.
  # If it fails, notify this to the user and confirm if restore should
  # proceed.

  echo -n "Restoring from $snapshot_file..."

  sed -n '1!p' "$snapshot_file" |
    while read line; do
      local version_hash="${line%% *}"
      local url="${line##* }"
      local clone_dir="$(-antigen-get-clone-dir "$url")"

      if [[ ! -d $clone_dir ]]; then
          git clone "$url" "$clone_dir" &> /dev/null
      fi

      (cd -q "$clone_dir" && git checkout $version_hash) &> /dev/null
    done

  echo ' done.'
  echo 'Please open a new shell to get the restored changes.'
}
# Reads $ADORDIR/revert-info and restores bundles' revision
antigen-revert () {
  local line
  if [[ -f $ADOTDIR/revert-info ]]; then
    cat $ADOTDIR/revert-info | sed -n '1!p' | while read line; do
      local dir="$(echo "$line" | cut -d: -f1)"
      git --git-dir="$dir/.git" --work-tree="$dir" \
        checkout "$(echo "$line" | cut -d: -f2)" 2> /dev/null
    done

    echo "Reverted to state before running -update on $(
            cat $ADOTDIR/revert-info | sed -n '1p')."

  else
    echo 'No revert information available. Cannot revert.' >&2
    return 1
  fi
}
# Update (with `git pull`) antigen itself.
# TODO: Once update is finished, show a summary of the new commits, as a kind of
# "what's new" message.
antigen-selfupdate () {
  ( cd -q $_ANTIGEN_INSTALL_DIR
   if [[ ! ( -d .git || -f .git ) ]]; then
     echo "Your copy of antigen doesn't appear to be a git clone. " \
       "The 'selfupdate' command cannot work in this case."
     return 1
   fi
   local head="$(git rev-parse --abbrev-ref HEAD)"
   if [[ $head == "HEAD" ]]; then
     # If current head is detached HEAD, checkout to master branch.
     git checkout master
   fi
   git pull

   # TODO Should be transparently hooked by zcache
   antigen-reset &>> /dev/null
  )
}
antigen-snapshot () {
  local snapshot_file="${1:-antigen-shapshot}"
  local urls url dir version_hash snapshot_content
  local -a bundles

  # The snapshot content lines are pairs of repo-url and git version hash, in
  # the form:
  #   <version-hash> <repo-url>
  urls=$(-antigen-echo-record | awk '$4 == "true" {print $1}' | sort -u)
  for url in ${(f)urls}; do
    dir="$(-antigen-get-clone-dir "$url")"
    version_hash="$(cd -q "$dir" && git rev-parse HEAD)"
    bundles+=("$version_hash $url");
  done
  snapshot_content=${(j:\n:)bundles}

  {
    # The first line in the snapshot file is for metadata, in the form:
    #   key='value'; key='value'; key='value';
    # Where `key`s are valid shell variable names.

    # Snapshot version. Has no relation to antigen version. If the snapshot
    # file format changes, this number can be incremented.
    echo -n "version='1';"

    # Snapshot creation date+time.
    echo -n " created_on='$(date)';"

    # Add a checksum with the md5 checksum of all the snapshot lines.
    chksum() { (md5sum; test $? = 127 && md5) 2>/dev/null | cut -d' ' -f1 }
    local checksum="$(echo "$snapshot_content" | chksum)"
    unset -f chksum;
    echo -n " checksum='${checksum%% *}';"

    # A newline after the metadata and then the snapshot lines.
    echo "\n$snapshot_content"

  } > "$snapshot_file"
}
# Loads a given theme.
#
# Shares the same syntax as antigen-bundle command.
#
# Usage
#   antigen-theme zsh/theme[.zsh-theme]
#
# Returns
#   0 if everything was succesfully
antigen-theme () {
  local record result=0
  local match mbegin mend MATCH MBEGIN MEND

  -antigen-theme-reset-hooks

  record=$(-antigen-find-record "theme")

  if [[ "$1" != */* && "$1" != --* ]]; then
    # The first argument is just a name of the plugin, to be picked up from
    # the default repo.
    local name="${1:-robbyrussell}"
    antigen-bundle --loc=themes/$name --btype=theme

  else
    antigen-bundle "$@" --btype=theme

  fi
  result=$?

  # Remove a theme from the record if the following conditions apply:
  #   - there was no error in bundling the given theme
  #   - there is a theme registered
  #   - registered theme is not the same as the current one
  if [[ $result == 0 && -n $record ]]; then
    # http://zsh-workers.zsh.narkive.com/QwfCWpW8/what-s-wrong-with-this-expression
    if [[ "$record" =~ "$@" ]]; then
      return $result
    else
      _ANTIGEN_BUNDLE_RECORD[$_ANTIGEN_BUNDLE_RECORD[(I)$record]]=()
    fi
  fi

  return $result
}

-antigen-theme-reset-hooks () {
  # This is only needed on interactive mode
  autoload -U add-zsh-hook is-at-least
  local hook

  # Clear out prompts
  PROMPT=""
  if [[ -n $RPROMPT ]]; then
    RPROMPT=""
  fi

  for hook in chpwd precmd preexec periodic; do
    add-zsh-hook -D "${hook}" "prompt_*"
    # common in omz themes
    add-zsh-hook -D "${hook}" "*_${hook}"
    add-zsh-hook -d "${hook}" "vcs_info"
  done
}
# Updates the bundles or a single bundle.
#
# Usage
#    antigen-update [example/bundle]
#
# Returns
#    Nothing. Performs a `git pull`.
antigen-update () {
  local bundle=$1 url

  # Clear log
  :> $ANTIGEN_LOG

  # Update revert-info data
  -antigen-revert-info

  # If no argument is given we update all bundles
  if [[ $# -eq 0  ]]; then
    # Here we're ignoring all non cloned bundles (ie, --no-local-clone)
    -antigen-get-cloned-bundles | while read url; do
      -antigen-update-bundle $url
    done
    # TODO next minor version
    # antigen-reset
  else
    if -antigen-update-bundle $bundle; then
      # TODO next minor version
      # antigen-reset
    else
      return $?
    fi
  fi
}

# Updates a bundle performing a `git pull`.
#
# Usage
#    -antigen-update-bundle example/bundle
#
# Returns
#    Nothing. Performs a `git pull`.
-antigen-update-bundle () {
  local bundle="$1"
  local record=""
  local url=""
  local make_local_clone=""
  local start=$(date +'%s')
    
  if [[ $# -eq 0 ]]; then
    printf "Antigen: Missing argument.\n" >&2
    return 1
  fi

  record=$(-antigen-find-record $bundle)
  if [[ ! -n "$record" ]]; then
    printf "Bundle not found in record. Try 'antigen bundle %s' first.\n" $bundle >&2
    return 1
  fi

  url="$(echo "$record" | cut -d' ' -f1)"
  make_local_clone=$(echo "$record" | cut -d' ' -f4)
  
  local branch="master"
  if [[ $url == *\|* ]]; then
    branch="$(-antigen-parse-branch ${url%|*} ${url#*|})"
  fi

  printf "Updating %s... " $(-antigen-bundle-short-name "$url" "$branch")
  
  if [[ $make_local_clone == "false" ]]; then
    printf "Bundle has no local clone. Will not be updated.\n" >&2
    return 1
  fi

  # update=true verbose=false
  if ! -antigen-ensure-repo "$url" true false; then
    printf "Error! Activate logging and try again.\n" >&2
    return 1
  fi
  
  local took=$(( $(date +'%s') - $start ))
  printf "Done. Took %ds.\n" $took
}
antigen-use () {
  if [[ $1 == oh-my-zsh ]]; then
    -antigen-use-oh-my-zsh
  elif [[ $1 == prezto ]]; then
    -antigen-use-prezto
  elif [[ $1 != "" ]]; then
    ANTIGEN_DEFAULT_REPO_URL=$1
    antigen-bundle $@
  else
    echo 'Usage: antigen-use <library-name|url>' >&2
    echo 'Where <library-name> is any one of the following:' >&2
    echo ' * oh-my-zsh' >&2
    echo ' * prezto' >&2
    echo '<url> is the full url.' >&2
    return 1
  fi
}

antigen-version () {
  local version="develop"
  local revision=""
  if [[ -d $_ANTIGEN_INSTALL_DIR/.git ]]; then
    revision=" ($(git --git-dir=$_ANTIGEN_INSTALL_DIR/.git rev-parse --short '@'))"
  fi

  printf "Antigen %s%s\n" $version $revision
}
typeset -Ag _ANTIGEN_HOOKS; _ANTIGEN_HOOKS=()
typeset -Ag _ANTIGEN_HOOKS_TARGET; _ANTIGEN_HOOKS_TARGET=()
typeset -Ag _ANTIGEN_HOOKS_TYPE; _ANTIGEN_HOOKS_TYPE=()
typeset -g _ANTIGEN_HOOK_PREFIX="::antigen-hook::"
# -antigen-add-hook antigen-apply antigen-apply-hook replace
#   - Replaces hooked function with hook, do not call it
# -antigen-add-hook antigen-apply antigen-apply-hook pre (pre-call)
#   - By default it will call hooked function
#   - Return -1 to stop from calling hooked function
# -antigen-add-hook antigen-pply antigen-apply-hook post (post-call)
#   - Calls antigen-apply and then calls hook function
#   - Return non-zero to overwrite return status
# Usage:
#  -antigen-add-hook antigen-apply antigen-apply-hook ["replace"|"pre"|"post"]
antigen-add-hook () {
  local target="$1" hook="$2" type="$3"
  
  if (( ! $+functions[$target] )); then
    printf "Antigen: Function %s doesn't exist.\n" $target
    return 1
  fi

  if (( ! $+functions[$hook] )); then
    printf "Antigen: Function %s doesn't exist.\n" $hook
    return 1
  fi

  if [[ "${_ANTIGEN_HOOKS[$target]}" == "" ]]; then
    _ANTIGEN_HOOKS[$target]="${hook}"
  else
    _ANTIGEN_HOOKS[$target]="${_ANTIGEN_HOOKS[$target]}:${hook}"
  fi

  _ANTIGEN_HOOKS_TARGET[$hook]="$target"
  _ANTIGEN_HOOKS_TYPE[$hook]="$type"
  
  # Do shadow for this function if there is none already
  local hook_function="${_ANTIGEN_HOOK_PREFIX}$target"
  if (( ! $+functions[$hook_function] )); then
    # Preserve hooked function
    eval "function ${_ANTIGEN_HOOK_PREFIX}$(functions -- $target)"

    # Create hook, call hook-handler to further process hook functions
    eval "function $target () {
      -antigen-hook-handler $target \${@//\*/\\\*}
      return \$?
    }"
  fi
  
  return 0
}

# Private function to handle multiple hooks in a central point.
-antigen-hook-handler () {
  local target="$1"
  shift
  local args=${@}

  typeset -a hooks; hooks=(${(s|:|)_ANTIGEN_HOOKS[$target]})

  local hook
  # A replace hook will return inmediately
  local replace_hook=0 ret
  for hook in $hooks; do
    if [[ ${_ANTIGEN_HOOKS_TYPE[$hook]} == "replace" ]]; then
      replace_hook=1
      # Should not be needed if `antigen-remove-hook` removed unneeded hooks.
      if (( $+functions[$hook] )); then
        eval $hook $args
        if [[ $? == -1 ]]; then
          break
        fi
      fi
    fi
  done

  if [[ $replace_hook == 1 ]]; then
    return $ret
  fi

  for hook in $hooks; do
    if [[ ${_ANTIGEN_HOOKS_TYPE[$hook]} == "pre" ]]; then
      eval $hook $args
    fi
  done

  eval "${_ANTIGEN_HOOK_PREFIX}$target" $args
  local res=$?

  for hook in $hooks; do
    if [[ ${_ANTIGEN_HOOKS_TYPE[$hook]} == "post" ]]; then
      eval $hook $args
    fi
  done
  
  return $res
}

# Usage:
#  -antigen-remove-hook antigen-apply-hook
antigen-remove-hook () {
  local hook="$1" target
  local -a hooks
  target=${_ANTIGEN_HOOKS_TARGET[$hook]}
  hooks=(${(s|:|)_ANTIGEN_HOOKS[$target]})

  # Remove registered hook
  hooks[$hooks[(I)$hook]]=()
  _ANTIGEN_HOOKS[$target]=${(j|:|)hooks}
  #_ANTIGEN_HOOKS_TARGET[$hook]=()
  
  if [[ $#hooks == 0 ]]; then
    # Destroy base hook
    eval "function $(functions -- ${_ANTIGEN_HOOK_PREFIX}$target | sed s/${_ANTIGEN_HOOK_PREFIX}//)"
    unfunction -- "${_ANTIGEN_HOOK_PREFIX}$target"
  fi

  unfunction -- $hook 2> /dev/null
}

# Remove all defined hooks.
-antigen-reset-hooks () {
  local target

  for target in ${(k)_ANTIGEN_HOOKS}; do
    # Release all hooked functions
    eval "function $(functions -- ${_ANTIGEN_HOOK_PREFIX}$target | sed s/${_ANTIGEN_HOOK_PREFIX}//)"
    unfunction -- "${_ANTIGEN_HOOK_PREFIX}$target"
  done
  
  _ANTIGEN_HOOKS=()
  _ANTIGEN_HOOKS_TYPE=()
}

# Initializes an extension
# Usage:
#  antigen-ext ext-name
antigen-ext () {
  local ext=$1
  local func="-antigen-$ext-init"
  if (( $+functions[$func] )); then
    eval $func
    eval "-antigen-$ext-execute"
  else
    printf "Antigen: No extension defined: %s\n" $func >&2
    return 1
  fi
}
# Initialize defer lib
-antigen-defer-init () {
  typeset -ga _DEFERRED_BUNDLE=()

  # Hooks antigen-bundle in order to defer its execution.
  antigen-bundle-defer () {
    _DEFERRED_BUNDLE+=("${(j: :)${@}}")
  }
  antigen-add-hook antigen-bundle antigen-bundle-defer replace
  
  # Hooks antigen-apply in order to release hooked functions
  antigen-apply-defer () {
    antigen-remove-hook antigen-bundle-defer
    # Process all deferred bundles.
    for bundle in $_DEFERRED_BUNDLE; do
      antigen-bundle ${=bundle}
    done

    antigen-remove-hook antigen-apply-defer
    unset _DEFERRED_BUNDLE
    antigen-apply "$@"
  }
  antigen-add-hook antigen-apply antigen-apply-defer replace
}
# Initialize lock lib
-antigen-lock-init () {
  # Default lock path.
  -antigen-set-default ANTIGEN_LOCK $ADOTDIR/.lock
  typeset -g _ANTIGEN_LOCK_PROCESS=false
}

-antigen-lock-execute () {
  # Hook antigen command in order to check/create a lock file.
  # This hook is only run once then releases itself.
  antigen-lock () {
    antigen-remove-hook antigen-lock

    # If there is a lock set up then we won't process anything.
    if [[ -f $ANTIGEN_LOCK ]]; then
      # Set up flag do the message is not repeated for each antigen-* command
      [[ $_ANTIGEN_LOCK_PROCESS == false ]] && printf "Antigen: Another process in running.\n"
      _ANTIGEN_LOCK_PROCESS=true
      # Do not further process hooks. For this hook to properly work it
      # should be registered first.
      return -1
    fi

    touch $ANTIGEN_LOCK

    # Call hooked function
    antigen "$@"
  }
  antigen-add-hook antigen antigen-lock replace

  # Hook antigen-apply in order to release .lock file.
  antigen-apply-lock () {
    # One time hook
    antigen-remove-hook antigen-apply-lock
    unset _ANTIGEN_LOCK_PROCESS
    rm $ANTIGEN_LOCK &> /dev/null
    antigen-apply "$@"
  }
  antigen-add-hook antigen-apply antigen-apply-lock replace
}
# Generates cache from listed bundles.
#
# Iterates over _ANTIGEN_BUNDLE_RECORD and join all needed sources into one,
# if this is done through -antigen-load-list.
# Result is stored in ANTIGEN_CACHE.
#
# _ANTIGEN_BUNDLE_RECORD and fpath is stored in cache.
#
# Usage
#   -zcache-generate-cache
#
# Returns
#   Nothing. Generates ANTIGEN_CACHE
-antigen-cache-generate () {
  local -aU _fpath _PATH _sources
  local record

  for record in $_ZCACHE_BUNDLE_SOURCE; do
    record=${record:A}
    if [[ -f $record ]]; then
      # Adding $'\n' as a suffix as j:\n: doesn't work inside a heredoc.
      _sources+=("source '${record}';"$'\n')
    elif [[ -d $record ]]; then
      _PATH+=("${record}")
      _fpath+=("${record}")

      # Support prezto function loading. See https://github.com/zsh-users/antigen/pull/428
      if [[ -d "${record}/functions" ]]; then
        _PATH+=("${record}/functions")
        _fpath+=("${record}/functions")
      fi

    fi
  done

cat > $ANTIGEN_CACHE <<EOC
#-- START ZCACHE GENERATED FILE
#-- GENERATED: $(date)
#-- ANTIGEN develop
$(functions -- _antigen)
antigen () {
  local MATCH MBEGIN MEND
  [[ "\$ZSH_EVAL_CONTEXT" =~ "toplevel:*" || "\$ZSH_EVAL_CONTEXT" =~ "cmdarg:*" ]] && source "$_ANTIGEN_INSTALL_DIR/antigen.zsh" && eval antigen \$@;
  return 0;
}
fpath+=(${_fpath[@]}); PATH="\$PATH:${(j/:/)_PATH}"
_antigen_compinit () {
  autoload -Uz compinit; compinit -C -d "$ANTIGEN_COMPDUMP"; compdef _antigen antigen
  add-zsh-hook -D precmd _antigen_compinit
}
autoload -Uz add-zsh-hook; add-zsh-hook precmd _antigen_compinit
compdef () {}

if [[ -n "$ZSH" ]]; then
  ZSH="$ZSH"; ZSH_CACHE_DIR="$ZSH_CACHE_DIR"
fi
#--- BUNDLES BEGIN
${(j::)_sources}
#--- BUNDLES END
typeset -gaU _ANTIGEN_BUNDLE_RECORD; _ANTIGEN_BUNDLE_RECORD=($(print ${(qq)_ANTIGEN_BUNDLE_RECORD}))
typeset -g _ANTIGEN_CACHE_LOADED=true ANTIGEN_CACHE_VERSION='develop'

#-- END ZCACHE GENERATED FILE
EOC

  { zcompile "$ANTIGEN_CACHE" } &!

  # Compile config files, if any
  [[ $ANTIGEN_AUTO_CONFIG == true && -n $ANTIGEN_CHECK_FILES ]] && {
    echo "$ANTIGEN_CHECK_FILES" >! "$ANTIGEN_RSRC"
    zcompile "$ANTIGEN_CHECK_FILES"
  } &!

  return true
}

# Initializes caching mechanism.
#
# Hooks `antigen-bundle` and `antigen-apply` in order to defer bundle install
# and load. All bundles are loaded from generated cache rather than dynamically
# as these are bundled.
#
# Usage
#  -antigen-cache-init
# Returns
#  Nothing
-antigen-cache-init () {
    typeset -ga _ZCACHE_BUNDLE_SOURCE _ZCACHE_CAPTURE_BUNDLE
    typeset -g _ZCACHE_CAPTURE_PREFIX
    _ZCACHE_CAPTURE_PREFIX=${_ZCACHE_CAPTURE_PREFIX:-"--zcache-"}
    _ZCACHE_BUNDLE_SOURCE=(); _ZCACHE_CAPTURE_BUNDLE=()

    # Compatibility with oh-my-zsh themes.
    -antigen-set-default _ANTIGEN_THEME_COMPAT true

    # Cache auto config files to check for changes (.zshrc, .antigenrc etc)
    -antigen-set-default ANTIGEN_AUTO_CONFIG true
    
    # Default cache path.
    -antigen-set-default ANTIGEN_CACHE $ADOTDIR/init.zsh
    -antigen-set-default ANTIGEN_RSRC $ADOTDIR/.resources
    
    return 0
}

-antigen-cache-execute () {
  # Main function. Deferred antigen-apply.
  antigen-apply-cached () {
    # Release function to apply
    antigen-remove-hook antigen-bundle-cached

    # Auto determine check_files
    # There always should be 5 steps from original source as the correct way is to use
    # `antigen` wrapper not `antigen-apply` directly and it's called by an extension.
    if [[ $ANTIGEN_AUTO_CONFIG == true && -z "$ANTIGEN_CHECK_FILES" && $#funcfiletrace -ge 5 ]]; then
      ANTIGEN_CHECK_FILES+=("${${funcfiletrace[5]%:*}##* }")
    fi
 
    local bundle
    for bundle in "${_ZCACHE_CAPTURE_BUNDLE[@]}"; do
      antigen-bundle ${=bundle[@]} 2> /dev/null
    done

    # Generate and compile cache
    -antigen-cache-generate
    
    # Release all hooked functions
    antigen-remove-hook antigen-apply-cached
    antigen-remove-hook -antigen-load-env-cached
    antigen-remove-hook -antigen-load-source-cached

    [[ -f "$ANTIGEN_CACHE" ]] && source "$ANTIGEN_CACHE";
    
    unset _ZCACHE_BUNDLE_SOURCE _ZCACHE_CAPTURE_BUNDLE _ZCACHE_CAPTURE_FUNCTIONS

    antigen-apply
  }
  antigen-add-hook antigen-apply antigen-apply-cached replace
  
  # Defer antigen-bundle.
  antigen-bundle-cached () {
    _ZCACHE_CAPTURE_BUNDLE+=("${(j: :)${@}}")
  }
  antigen-add-hook antigen-bundle antigen-bundle-cached replace

  # Defer loading.
  -antigen-load-env-cached () {
    typeset -A bundle; bundle=($@)
    local location=${bundle[path]}/${bundle[loc]}
    
    # Load to path if there is no sourceable
    if [[ ${bundle[loc]} == "/" ]]; then
      _ZCACHE_BUNDLE_SOURCE+=("${location}")
      return
    fi

    _ZCACHE_BUNDLE_SOURCE+=("${location}")
  }
  antigen-add-hook -antigen-load-env -antigen-load-env-cached replace
  
  # Defer sourcing.
  -antigen-load-source-cached () {
    _ZCACHE_BUNDLE_SOURCE+=(${list})
  }
  antigen-add-hook -antigen-load-source -antigen-load-source-cached replace
  
  return 0
}
#compdef _antigen
# Setup antigen's autocompletion
_antigen () {
  local -a _1st_arguments
  _1st_arguments=(
    'apply:Load all bundle completions'
    'bundle:Install and load the given plugin'
    'bundles:Bulk define bundles'
    'cleanup:Clean up the clones of repos which are not used by any bundles currently loaded'
    'cache-gen:Generate cache'
    'init:Load Antigen configuration from file'
    'list:List out the currently loaded bundles'
    'purge:Remove a cloned bundle from filesystem'
    'reset:Clears cache'
    'restore:Restore the bundles state as specified in the snapshot'
    'revert:Revert the state of all bundles to how they were before the last antigen update'
    'selfupdate:Update antigen itself'
    'snapshot:Create a snapshot of all the active clones'
    'theme:Switch the prompt theme'
    'update:Update all bundles'
    'use:Load any (supported) zsh pre-packaged framework'
  );

  _1st_arguments+=(
    'help:Show this message'
    'version:Display Antigen version'
  )

  __bundle() {
    _arguments \
      '--loc[Path to the location <path-to/location>]' \
      '--url[Path to the repository <github-account/repository>]' \
      '--branch[Git branch name]' \
      '--no-local-clone[Do not create a clone]'
  }
  __list() {
    _arguments \
      '--simple[Show only bundle name]' \
      '--short[Show only bundle name and branch]' \
      '--long[Show bundle records]'
  }


  __cleanup() {
    _arguments \
      '--force[Do not ask for confirmation]'
  }

  _arguments '*:: :->command'

  if (( CURRENT == 1 )); then
    _describe -t commands "antigen command" _1st_arguments
    return
  fi

  local -a _command_args
  case "$words[1]" in
    bundle)
      __bundle
      ;;
    use)
      compadd "$@" "oh-my-zsh" "prezto"
      ;;
    cleanup)
      __cleanup
      ;;
    (update|purge)
      compadd $(type -f \-antigen-get-bundles &> /dev/null || antigen &> /dev/null; -antigen-get-bundles --simple 2> /dev/null)
      ;;
    theme)
      compadd $(type -f \-antigen-get-themes &> /dev/null || antigen &> /dev/null; -antigen-get-themes 2> /dev/null)
      ;;
    list)
      __list
    ;;
  esac
}

-antigen-env-setup
